
icc.gym.dispatchers {

    work-dispatcher {
      # Dispatcher is the name of the event-based dispatcher
      type = Dispatcher
      # What kind of ExecutionService to use
      executor = "thread-pool-executor"
      # Configuration for the thread pool
      thread-pool-executor {
        # minimum number of threads to cap factor-based core number to
        core-pool-size-min = 10
        # No of core threads ... ceil(available processors * factor)
        core-pool-size-factor = 8.0
        # maximum number of threads to cap factor-based number to
        core-pool-size-max = 300
      }
      # Throughput defines the maximum number of messages to be
      # processed per actor before the thread jumps to the next actor.
      # Set to 1 for as fair as possible.
      throughput = 100
    }

}


akka {

  log-config-on-start = off     # dumps out configuration onto console when enabled and loglevel >= "INFO"
  stdout-loglevel     = "INFO"  # startup log level
  loglevel            = "DEBUG"

  # Event handlers to register at boot time (Logging$DefaultLogger logs to STDOUT)
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]

  actor {
      debug  {
         #  enable DEBUG logging of subscription changes on the eventStream
         "event-stream" : "on",

         #  enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill and the like)
         "autoreceive" : "on",

         #  enable DEBUG logging of actor lifecycle changes
         "lifecycle" : "on",

         #  enable DEBUG logging of all LoggingFSMs for events, transitions and timers
          "fsm" : "off",

         #  enable function of Actor.loggable(), which is to log any received message at
         #  DEBUG level, see the “Testing Actor Systems” section of the Akka Documentation
         #  at http://akka.io/docs
         "receive" : "on"
      }
  }    
}

